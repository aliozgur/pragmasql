<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Script_GetInlinedTableFunctions" xml:space="preserve">
    <value>declare @compLevel smallint
select @compLevel = {0}

select
  so.*,
  CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END 'owner',
  
  CASE WHEN @compLevel &lt; 90 
	THEN  
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (USER_NAME(so.uid)) + '.' + (so.name)
	    END  
	ELSE 
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)
	    END  
  END 'FullName'
from sysobjects so
where 
   ( so.xtype = 'IF' ) AND (category = 0)
order by
 CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END,
  so.name</value>
  </data>
  <data name="Script_CodeCompletionProposal" xml:space="preserve">
    <value>DECLARE @r table
(
  [Order] int null,
  Type varchar(10) null,
  Catalog sysname null,
  [Schema] sysname null,
  ParentName sysname null,
  Name sysname null,
  DisplayName sysname null,
  DataType sysname null,
  IsOffline bit
)


-- databases
insert into @r([Order], Type,Name,DisplayName )
select
  0
  ,'Db'  
  , name 
  , name
from  master..sysdatabases 

-- Users
insert into @r( [Order],Type,Name,DisplayName )
select 
  1
  ,'Usr' 
  ,name
  ,name
from sysusers

-- Tables
insert into @r([Order], Type,Catalog,[Schema],ParentName, Name, DisplayName )
select
  2 
  ,'Tbl',TABLE_CATALOG, TABLE_SCHEMA,'', TABLE_NAME , TABLE_NAME
from  INFORMATION_SCHEMA.TABLES 
where TABLE_TYPE = 'BASE TABLE'

-- Views
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DisplayName )
select
  3 
  , 'Vw', TABLE_CATALOG, TABLE_SCHEMA, '', TABLE_NAME, TABLE_NAME
from  INFORMATION_SCHEMA.VIEWS 

-- Procedures
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DisplayName )
select 
  CASE ROUTINE_TYPE 
    WHEN 'PROCEDURE' THEN 4
    WHEN 'FUNCTION' THEN 5
    ELSE 1000
  END,
  CASE ROUTINE_TYPE 
    WHEN 'PROCEDURE' THEN 'Pr'
    WHEN 'FUNCTION' THEN 'Fu'
    ELSE '?'
  END,  
  ROUTINE_CATALOG, ROUTINE_SCHEMA,'', ROUTINE_NAME, ROUTINE_NAME
from INFORMATION_SCHEMA.ROUTINES 

-- Triggers
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DisplayName )
select
  6,
  'Tr',
  '',
  '',
  po.name,
  o.name,
  o.name
from sysobjects o
join sysobjects po on o.parent_obj = po.id
where o.xtype = 'tr'

-- Table Columns
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DataType, DisplayName )
select 
  7
 , 'Col'
 , TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, DATA_TYPE
 , CASE 
    WHEN DATA_TYPE = 'varchar' THEN COLUMN_NAME + ' ' + DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar)+ ')'
    WHEN DATA_TYPE = 'nvarchar' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'char' THEN COLUMN_NAME + ' ' +   DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nchar' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'binary' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nbinary' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'numeric' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar)+ ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
    WHEN DATA_TYPE = 'decimal' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar) + ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
  ELSE  COLUMN_NAME + ' ' + DATA_TYPE END
from INFORMATION_SCHEMA.COLUMNS 

-- View Columns
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DisplayName )
select 
  8
 ,'Col'
 , VIEW_CATALOG, VIEW_SCHEMA, VIEW_NAME, COLUMN_NAME , COLUMN_NAME
from INFORMATION_SCHEMA.VIEW_COLUMN_USAGE 


-- Procedure Params
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DataType, DisplayName )
select
  9
  ,'Param'
  ,  SPECIFIC_CATALOG, SPECIFIC_SCHEMA, SPECIFIC_NAME,PARAMETER_NAME, DATA_TYPE
 , CASE 
    WHEN DATA_TYPE = 'varchar' THEN PARAMETER_NAME + ' ' + DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar)+ ')'
    WHEN DATA_TYPE = 'nvarchar' THEN PARAMETER_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'char' THEN PARAMETER_NAME + ' ' +  DATA_TYPE +  '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nchar' THEN PARAMETER_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'binary' THEN PARAMETER_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nbinary' THEN PARAMETER_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'numeric' THEN PARAMETER_NAME + ' ' +  DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar)+ ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
    WHEN DATA_TYPE = 'decimal' THEN PARAMETER_NAME + ' ' +  DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar) + ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
  ELSE  PARAMETER_NAME + ' ' + DATA_TYPE END

from INFORMATION_SCHEMA.PARAMETERS 


select * from @r
order by [Order],Name</value>
  </data>
  <data name="Script_ForeignKeyIn" xml:space="preserve">
    <value>EXEC sp_fkeys @pktable_name = N</value>
  </data>
  <data name="Script_GetTableValuedFunctions" xml:space="preserve">
    <value>declare @compLevel smallint
select @compLevel = {0}

select
  so.*,
  CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END 'owner',
  
  CASE WHEN @compLevel &lt; 90 
	THEN  
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (USER_NAME(so.uid)) + '.' + (so.name)
	    END  
	ELSE 
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)
	    END  
  END 'FullName'
from sysobjects so
where 
   ( (so.xtype = 'TF') OR (so.xtype = 'IF') ) AND (category = 0)
order by
 CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END,
  so.name</value>
  </data>
  <data name="Script_GetTriggers" xml:space="preserve">
    <value>declare @compLevel smallint
select @compLevel = {0}

select
  so.*,
  CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END 'owner',
  CASE WHEN @compLevel &lt; 90 
	THEN  (USER_NAME(so.uid)) + '.' + (so.name)  
	ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)  
  END 'FullName'
from sysobjects so
where 
   so.xtype = 'TR' and so.parent_obj = @parentid
order by
  CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END
  ,so.name</value>
  </data>
  <data name="Script_GetViews" xml:space="preserve">
    <value>select
  so.*
  , 
  CASE WHEN t.TABLE_SCHEMA IS NULL 
	THEN ''
	ELSE (t.TABLE_SCHEMA) 
  END AS 'owner' 
  ,CASE WHEN t.TABLE_SCHEMA IS NULL 
	THEN (so.name)
	ELSE (t.TABLE_SCHEMA) + '.' + (so.name)  
   END AS FullName
	
from sysobjects so
left outer join INFORMATION_SCHEMA.VIEWS t on so.name = t.TABLE_NAME
where 
  ( so.xtype = 'V')
order by
 (t.TABLE_SCHEMA),
 so.name</value>
  </data>
  <data name="Script_GetDatabases" xml:space="preserve">
    <value>DECLARE @r table
(
  [dbid] smallint not null,
  [Order] int null,
  Type varchar(10) null,
  Catalog sysname null,
  [Schema] sysname null,
  ParentName sysname null,
  Name sysname null,
  DataType sysname null,
  CompatibilityLevel tinyint null
)


-- databases
insert into @r([dbid],[Order], Type,Name,CompatibilityLevel )
select
  [dbid]
  ,0
  ,'Db'  
  , name
  , cmptlevel 
from  master..sysdatabases 

select * from @r</value>
  </data>
  <data name="Script_GetUserTables" xml:space="preserve">
    <value>select
  so.*
  , 
  CASE WHEN t.TABLE_SCHEMA IS NULL 
	THEN ''
	ELSE (t.TABLE_SCHEMA) 
  END AS 'owner' 
  ,CASE WHEN t.TABLE_SCHEMA IS NULL 
	THEN (so.name)
	ELSE (t.TABLE_SCHEMA) + '.' + (so.name)  
   END AS FullName
	
from sysobjects so
left outer join INFORMATION_SCHEMA.TABLES t on so.name = t.TABLE_NAME
where 
  ( so.xtype = 'U')
order by
 (t.TABLE_SCHEMA),
 so.name</value>
  </data>
  <data name="Script_Permissions" xml:space="preserve">
    <value>select 
  [Object] = o.name , 
  user_name(p.uid) as 'UserOrRole', 
  CASE action
    WHEN 193 THEN 'SELECT'
    WHEN 195 THEN 'INSERT'
    WHEN 196 THEN 'DELETE'
    WHEN 197 THEN 'UPDATE'
    WHEN 224 THEN 'EXECUTE'
    WHEN 26 THEN 'REFERENCES'
    ELSE '?'
  END as 'Action',
  CASE protecttype
    WHEN 204 THEN 'GRANT_W_GRANT'
    WHEN 205 THEN 'GRANT'
    WHEN 206 THEN 'DENY'
    ELSE '?'
  END as 'ProtectType' 
from dbo.sysprotects p, dbo.sysobjects o
where 
  o.id = p.id 
  and p.action in (193, 195, 196, 197, 224, 26) 
  and p.id = $objid$  
order by [Object]</value>
  </data>
  <data name="Script_GetUsers" xml:space="preserve">
    <value>DECLARE @r table
(
  [Order] int null,
  Type varchar(10) null,
  Catalog sysname null,
  [Schema] sysname null,
  ParentName sysname null,
  Name sysname null,
  DataType sysname null
)
DECLARE @cmplevel int SELECT @cmplevel = cmptlevel FROM master..sysdatabases where name = DB_NAME() 

-- Users
IF @cmplevel &lt; 90 BEGIN 
	INSERT INTO @r( [Order],Type,Name )
    SELECT 1, 'Usr', name FROM sysusers WHERE uid!=0 AND isaliased=0 ORDER BY uid
END ELSE BEGIN
	INSERT INTO @r( [Order],Type,Name )
    SELECT 1, 'Usr',name from sys.schemas
END    

select * from @r</value>
  </data>
  <data name="Script_GetStoredProcedures" xml:space="preserve">
    <value>declare @compLevel smallint
select @compLevel = {0}

select
  so.*,
  CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END 'owner',
  
  CASE WHEN @compLevel &lt; 90 
	THEN  
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (USER_NAME(so.uid)) + '.' + (so.name)
	    END  
	ELSE 
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)
	    END  
  END 'FullName'
from sysobjects so
where 
    (so.xtype = 'P' or so.xtype = 'X' or so.xtype = 'RF') AND (category = 0)
order by
 CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END,
  so.name</value>
  </data>
  <data name="Script_GetScalarValuedFunctions" xml:space="preserve">
    <value>declare @compLevel smallint
select @compLevel = {0}

select
  so.*,
  CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END 'owner',
  
  CASE WHEN @compLevel &lt; 90 
	THEN  
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (USER_NAME(so.uid)) + '.' + (so.name)
	    END  
	ELSE 
		CASE WHEN so.uid IS NULL 
			THEN (so.name)  
			ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)
	    END  
  END 'FullName'
from sysobjects so
where 
    (so.xtype = 'FN') AND (category = 0)
order by
 CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END,
  so.name</value>
  </data>
  <data name="Script_GetSystemTables" xml:space="preserve">
    <value>select
  so.*
  , 
  CASE WHEN t.TABLE_SCHEMA IS NULL 
	THEN ''
	ELSE (t.TABLE_SCHEMA) 
  END AS 'owner' 
  ,CASE WHEN t.TABLE_SCHEMA IS NULL 
	THEN (so.name)
	ELSE (t.TABLE_SCHEMA) + '.' + (so.name)  
   END AS FullName
	
from sysobjects so
left outer join INFORMATION_SCHEMA.TABLES t on so.name = t.TABLE_NAME
where 
  ( so.xtype = 'S')
order by
 (t.TABLE_SCHEMA),
 so.name</value>
  </data>
  <data name="Script_GetColsAndParams" xml:space="preserve">
    <value>;WITH cols AS
(
    SELECT
        c.column_id                               AS colorder,
        c.name                                    AS name,
        CASE WHEN ty.is_user_defined = 1
             THEN QUOTENAME(SCHEMA_NAME(ty.schema_id)) + N'.' + QUOTENAME(ty.name)
             ELSE ty.name
        END                                       AS typename,
        CASE
            WHEN ty.name IN (N'nchar', N'nvarchar')
                 THEN CASE WHEN c.max_length = -1 THEN -1 ELSE c.max_length / 2 END
            ELSE c.max_length
        END                                       AS lengthx,
        c.[precision]                             AS prec,
        c.scale                                   AS scale,
        o.[type]                                  AS parenttype,

        -- legacy-compatible bitmask:
        -- 0x08 = nullable, 0x80 = identity, (optionally 0x10 = computed, 0x04 = rowguid)
        ((CASE WHEN c.is_nullable = 1 THEN 0x08 ELSE 0 END) +
         (CASE WHEN c.is_identity = 1 THEN 0x80 ELSE 0 END) +
         (CASE WHEN c.is_computed = 1 THEN 0x10 ELSE 0 END) +
         (CASE WHEN c.is_rowguidcol = 1 THEN 0x04 ELSE 0 END)) AS status,

        CONVERT(bit, c.is_nullable)               AS allownulls,
        CONVERT(bit, 0)                           AS isoutputparam,
        CONVERT(bit, c.is_identity)               AS isidentity,
        SCHEMA_NAME(o.schema_id)                  AS owner
    FROM sys.columns AS c
    JOIN sys.objects AS o     ON o.object_id = c.object_id
    JOIN sys.types   AS ty    ON ty.user_type_id = c.user_type_id
    WHERE c.object_id = @id
),
prms AS
(
    SELECT
        p.parameter_id                            AS colorder,
        p.name                                    AS name,
        CASE WHEN ty.is_user_defined = 1
             THEN QUOTENAME(SCHEMA_NAME(ty.schema_id)) + N'.' + QUOTENAME(ty.name)
             ELSE ty.name
        END                                       AS typename,
        CASE
            WHEN ty.name IN (N'nchar', N'nvarchar')
                 THEN CASE WHEN p.max_length = -1 THEN -1 ELSE p.max_length / 2 END
            ELSE p.max_length
        END                                       AS lengthx,
        p.[precision]                             AS prec,
        p.scale                                   AS scale,
        o.[type]                                  AS parenttype,

        -- legacy-compatible bitmask for parameters:
        -- 0x08 = nullable, 0x40 = output
        ((CASE WHEN p.is_nullable = 1 THEN 0x08 ELSE 0 END) +
         (CASE WHEN p.is_output   = 1 THEN 0x40 ELSE 0 END))   AS status,

        CONVERT(bit, p.is_nullable)               AS allownulls,
        CONVERT(bit, p.is_output)                 AS isoutputparam,
        CONVERT(bit, 0)                           AS isidentity,
        SCHEMA_NAME(o.schema_id)                  AS owner
    FROM sys.parameters AS p
    JOIN sys.objects    AS o  ON o.object_id = p.object_id
    JOIN sys.types      AS ty ON ty.user_type_id = p.user_type_id
    WHERE p.object_id = @id
)
SELECT *
FROM cols
UNION ALL
SELECT * FROM prms
ORDER BY isidentity DESC, colorder, name;
</value>
  </data>
  <data name="Script_ForeignKeys" xml:space="preserve">
    <value>EXEC sp_fkeys @fktable_name = N</value>
  </data>
  <data name="Script_ReferencesAny" xml:space="preserve">
    <value>SET NOEXEC OFF
SELECT distinct o.name, o.xtype, o.id
from syscomments c
join sysobjects o on o.id = c.id
where o.name != '{0}'
and (c.text like'%{0}%' or c.text like'%{0}(%')</value>
  </data>
  <data name="Script_ReferencesObject" xml:space="preserve">
    <value>SET NOEXEC OFF
SELECT distinct o.name, o.xtype, o.id
from syscomments c
join sysobjects o on o.id = c.id
where o.name != '{0}'
and (c.text like '% {0} %' or c.text like '% {0}(%' or c.text like '% {0} (%'
or c.text like '%.{0} %' or c.text like '%.{0}(%')</value>
  </data>
  <data name="Script_GetObjectInfoByName" xml:space="preserve">
    <value>
declare @cmplevel int
select @cmplevel = cmptlevel 
from  master..sysdatabases 
where name = DB_NAME()

select TOP 1 
 o.name,
 o.xtype,
 o.id ,CASE WHEN @cmplevel  &lt; 90 THEN  USER_NAME(o.uid) ELSE SCHEMA_NAME(o.uid) END 'owner'
from  sysobjects o
where o.name = '{0}'</value>
  </data>
  <data name="Script_GetObjectScriptByName" xml:space="preserve">
    <value>select 
text 
from sysobjects AS o 
join syscomments c on c.id = o.id 
where o.name = '{0}' 
order by o.name</value>
  </data>
  <data name="Script_GetObjectCreateScript" xml:space="preserve">
    <value>if exists (select * from dbo.syscomments where id=@id) 
  select 
    c.text, 
    c.encrypted, 
    c.number, 
    xtype=convert(nchar(2), o.xtype),     
    datalength(c.text), 
    convert(varbinary(8000), c.text), 0 
from dbo.syscomments c, dbo.sysobjects o     
where o.id = c.id and c.id = @id
order by c.number, c.colid option(robust plan)</value>
  </data>
  <data name="spHelp" xml:space="preserve">
    <value>exec sp_help '{0}'</value>
  </data>
  <data name="spHelp_constraints" xml:space="preserve">
    <value>exec sp_helpconstraint '{0}'</value>
  </data>
  <data name="spHelp_Depends" xml:space="preserve">
    <value>exec sp_depends '{0}'</value>
  </data>
  <data name="spHelp_foreignkeys" xml:space="preserve">
    <value>exec sp_fkeys @fktable_name = N'{0}',@fktable_owner = N'{1}'</value>
  </data>
  <data name="spHelp_foreignkeysin" xml:space="preserve">
    <value>exec sp_fkeys @pktable_name = N'{0}',@pktable_owner = N'{1}'</value>
  </data>
  <data name="spHelp_IdentityColumns" xml:space="preserve">
    <value>exec sp_special_columns '{0}','{1}'</value>
  </data>
  <data name="spHelp_Statistics" xml:space="preserve">
    <value>exec sp_statistics '{0}','{1}'</value>
  </data>
  <data name="spHelp_table_permissions" xml:space="preserve">
    <value>exec sp_table_privileges '{0}'</value>
  </data>
  <data name="spHelp_UsedSpace" xml:space="preserve">
    <value>exec sp_spaceused '{0}'</value>
  </data>
  <data name="Script_SearchDbExtended" xml:space="preserve">
    <value>declare @cmpLevel int
select @cmpLevel = cmptlevel 
from  master..sysdatabases 
where name = DB_NAME()


DECLARE @id int, @text nvarchar(4000), @ptrval varbinary(16)
DECLARE @newtext nvarchar(4000), @ObjectName varchar(255), @QuoteOwnerName varchar(1000), @OwnerName varchar(511), @ varchar(1000)

CREATE TABLE #Objects (id int, ObjectOwner varchar(255), ObjectName varchar(255), xtype char(2), QuoteOwnerName varchar(1000), OwnerName varchar(511), ObjectText text, ColText text)
INSERT INTO #Objects (id, ObjectOwner, ObjectName, xtype, QuoteOwnerName, OwnerName, ObjectText, ColText)

SELECT 
	so.id
	,CASE WHEN @cmpLevel &lt; 90 
		THEN  USER_NAME(so.uid) 
		ELSE SCHEMA_NAME(so.uid)
	 END   
	,name, xtype
	,CASE WHEN @cmpLevel &lt; 90 
		THEN  (USER_NAME(so.uid)) + '.' + (so.name)  
		ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)  
	  END
	,CASE WHEN @cmpLevel &lt; 90 
		THEN  USER_NAME(so.uid) + '.' + so.name  
		ELSE SCHEMA_NAME(so.uid) + '.' + so.name  
	  END
	, '',''
FROM dbo.sysobjects so
WHERE $typeCriteria$

DECLARE ACursor CURSOR FAST_FORWARD READ_ONLY FOR 
SELECT o.id, c.text 
FROM dbo.sysobjects AS o 
JOIN #Objects on o.id = #Objects.id
LEFT OUTER JOIN dbo.syscomments AS c ON c.id = o.id
ORDER BY o.id, c.colid

OPEN ACursor FETCH NEXT FROM ACursor INTO @id, @text
WHILE @@FETCH_STATUS = 0
	BEGIN
		SELECT @ObjectName = ObjectName, @QuoteOwnerName = QuoteOwnerName, @OwnerName = OwnerName, @ = (ObjectName) FROM #Objects WHERE id = @id
		SET @newtext = REPLACE(@text, @QuoteOwnerName, '')
			
		IF @newtext = @text BEGIN
			SET @newtext = REPLACE(@text, @OwnerName, '')
			IF @newtext = @text BEGIN
				SET @newtext = REPLACE(@text, @, '')
				IF @newtext = @text BEGIN
					SET @newtext = REPLACE(@text, @ObjectName, '')
				END
			END
		END
		
		SELECT @ptrval = TEXTPTR(ObjectText) FROM #Objects WHERE id = @id
		UPDATETEXT #Objects.ObjectText @ptrval NULL 0 @newtext
		
		 DECLARE ColumnCursor CURSOR FOR
		 SELECT co.name + ' ' + t.name + CASE WHEN (t.variable = 1) AND (t.xusertype = t.xtype) THEN '(' + CAST(co.length AS varchar(50)) + ')' ELSE '' END + CHAR(13)
		 FROM dbo.syscolumns AS co INNER JOIN dbo.systypes AS t ON t.xusertype = co.xusertype WHERE co.id = OBJECT_ID(@QuoteOwnerName)

                 

			OPEN ColumnCursor FETCH NEXT FROM ColumnCursor INTO @newtext
                  WHILE @@FETCH_STATUS = 0 BEGIN
                        SELECT @ptrval = TEXTPTR(ColText) FROM #Objects WHERE id = @id
                        UPDATETEXT #Objects.ColText @ptrval NULL 0 @newtext
                        FETCH NEXT FROM ColumnCursor INTO @newtext
                  END 
		    CLOSE ColumnCursor DEALLOCATE ColumnCursor
       FETCH NEXT FROM ACursor INTO @id, @text
	END

CLOSE ACursor
DEALLOCATE ACursor

SELECT id, ObjectOwner, ObjectName, xtype, QuoteOwnerName, OwnerName FROM #Objects
WHERE $criteria$
ORDER BY OwnerName

DROP TABLE #Objects</value>
  </data>
  <data name="Script_Schema_Columns" xml:space="preserve">
    <value>select 
  * 
from INFORMATION_SCHEMA.COLUMNS 
where TABLE_NAME = '{0}' 
order by ORDINAL_POSITION</value>
  </data>
  <data name="Script_Schema_RoutineParams" xml:space="preserve">
    <value>select 
  *
from INFORMATION_SCHEMA.PARAMETERS 
where SPECIFIC_NAME = '{0}' 
order by ORDINAL_POSITION</value>
  </data>
  <data name="Script_Schema_RoutineColumns" xml:space="preserve">
    <value>select 
  * 
from INFORMATION_SCHEMA.ROUTINE_COLUMNS
where TABLE_NAME = '{0}'
order by ORDINAL_POSITION</value>
  </data>
  <data name="Script_ObjectGroupingSupport" xml:space="preserve">
    <value>IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[PragmaSQLObjectGroup]') AND type in (N'U'))
BEGIN
CREATE TABLE [dbo].[PragmaSQLObjectGroup](
	[ObjectID] [int] IDENTITY(1,1) NOT NULL,
	[ParentID] [int] NULL,
	[Name] [varchar](4000) NULL,
	[ParentObjName] [varchar](4000) NULL,
	[Description] [text] NULL,
	[DescriptionFormat] [varchar](5) NULL,
	[ObjType] [int] NULL,
	[CreatedBy] [varchar](50) NULL,
	[CreatedOn] [datetime] NULL,
	[UpdatedBy] [varchar](50) NULL,
 CONSTRAINT [PK_PragmaSQLObjectGroup] PRIMARY KEY CLUSTERED 
(
	[ObjectID] ASC
) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END

IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_Delete]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[spPragmaSQL_ObjectGroup_Delete]
@ObjectID int
as begin
  -- Delete child objects recursively
  DECLARE @Param int

  DECLARE oCur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
  SELECT ObjectID
  FROM   PragmaSQLObjectGroup where ParentID = @ObjectID

  OPEN oCur
  WHILE (1=1) BEGIN
    FETCH NEXT FROM oCur INTO @Param
    IF @@FETCH_STATUS &lt;&gt; 0  BREAK

    exec dbo.[spPragmaSQL_ObjectGroup_Delete] @Param

  END
  CLOSE oCur
  DEALLOCATE oCur

  delete PragmaSQLObjectGroup
  where ObjectID = @ObjectID


end
' 
END

IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[spPragmaSQL_ObjectGroup_Update]
@ObjectID int
, @ParentID int
, @Name varchar(4000)
, @UpdatedBy varchar(50) 
as begin
  declare @oldParentID int

  select @oldParentID = ParentID 
  from PragmaSQLObjectGroup  
  where ObjectID = @ObjectID
  
  -- Parent not changed
  if( ISNULL(@oldParentID,-1 ) = @ParentID ) begin
    if exists(
                select ObjectID 
                from PragmaSQLObjectGroup 
                where ( ObjectID &lt;&gt; @ObjectID ) and ( Name = @Name) 
              ) 
    begin
      raiserror(''Item with name "%s" already exists under this folder!'',16,1,@Name)
      return
    end
  end else begin
    if exists(
                select ObjectID 
                from PragmaSQLObjectGroup 
                where ( ParentID = @ParentID ) and ( Name = @Name) 
              ) 
     begin
      raiserror(''Item with name "%s" already exists under this folder!'',16,1,@Name)
      return
    end    
  end
  
  update PragmaSQLObjectGroup
  set
    ParentID = @ParentID
    , Name = @Name
    , UpdatedBy = @UpdatedBy
  where ObjectID = @ObjectID
end
' 
END

IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_List]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [dbo].[spPragmaSQL_ObjectGroup_List]
@ParentID int = null
as begin
 select 
  	OG.*
  	, CASE WHEN ISNULL(SO.id,-1) &lt;&gt; -1
  			THEN CAST(1 as bit)
  			ELSE CAST(0 as bit)
  		END as DBObjectExists
  from PragmaSQLObjectGroup OG
  left outer join sysobjects SO on OG.Name = SO.Name
  where ( ISNULL(OG.ParentID,-1) = ISNULL(@ParentID,-1) )
  order by OG.ObjType, OG.Name
end

' 
END

IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_Insert]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


CREATE PROCEDURE [dbo].[spPragmaSQL_ObjectGroup_Insert]
@ParentID int,
@Name varchar(4000) ,
@ParentObjName varchar(4000),
@Description text,
@DescriptionFormat varchar(5) ,
@ObjType int,
@CreatedBy  varchar(50),
@ObjectID int output
as begin
  if exists(select ObjectID from  PragmaSQLObjectGroup where ParentID = @ParentID and Name = @Name) begin
    raiserror(''Item with name "%s" already exists under this folder!'',16,1,@Name)
    return
  end

  insert into PragmaSQLObjectGroup
  (
    ParentID ,
    Name ,
    ParentObjName,
    Description ,
    DescriptionFormat ,
    ObjType,
    CreatedBy,
    CreatedOn 
  )
  values
  (
    @ParentID ,
    @Name ,
    @ParentObjName,
    @Description ,
    @DescriptionFormat ,
    @ObjType,
    @CreatedBy,
    GetDate()
  )

  set @ObjectID = @@IDENTITY
end
'
END


IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_UpdateDescription]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[spPragmaSQL_ObjectGroup_UpdateDescription]
@ObjectID int
, @Description text
, @DescriptionFormat varchar(5)
, @UpdatedBy varchar(50) 
as begin
  update PragmaSQLObjectGroup
  set
    Description = @Description
    , DescriptionFormat = @DescriptionFormat
    , UpdatedBy = @UpdatedBy
  where ObjectID = @ObjectID
end
'
END


IF NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_GetHelpText]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[spPragmaSQL_ObjectGroup_GetHelpText]
@ObjectID int
as begin
  select 
    Description,
    DescriptionFormat,
    UpdatedBy 
  from PragmaSQLObjectGroup
  where ObjectID = @ObjectID
end

'
END</value>
  </data>
  <data name="spPragmaSQL_ObjectGroup_List" xml:space="preserve">
    <value>exec spPragmaSQL_ObjectGroup_List @ParentID</value>
  </data>
  <data name="spPragmaSQL_ObjectGroup_Insert" xml:space="preserve">
    <value>exec spPragmaSQL_ObjectGroup_Insert @ParentID ,@Name, @ParentObjName ,@Description ,@DescriptionFormat ,@ObjType ,@CreatedBy, @ObjectID out
</value>
  </data>
  <data name="spPragmaSQL_ObjectGroup_Delete" xml:space="preserve">
    <value>exec spPragmaSQL_ObjectGroup_Delete @ObjectID</value>
  </data>
  <data name="spPragmaSQL_ObjectGroup_UpdateDescription" xml:space="preserve">
    <value>exec spPragmaSQL_ObjectGroup_UpdateDescription @ObjectID, @Description, @DescriptionFormat, @UpdatedBy</value>
  </data>
  <data name="spPragmaSQL_ObjectGroup_GetHelpText" xml:space="preserve">
    <value>exec spPragmaSQL_ObjectGroup_GetHelpText @ObjectID</value>
  </data>
  <data name="spPragmaSQL_ObjectGroup_Update" xml:space="preserve">
    <value>exec spPragmaSQL_ObjectGroup_Update @ObjectID ,@ParentID , @Name, @UpdatedBy</value>
  </data>
  <data name="Script_ObjectGroupingSupportCheck" xml:space="preserve">
    <value>IF 
( 
  NOT EXISTS ( SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[PragmaSQLObjectGroup]') AND type in (N'U'))
)
OR
( 
 NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_Delete]') AND type in (N'P', N'PC'))
)
OR
(
  NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_Update]') AND type in (N'P', N'PC'))
)
OR
(
  NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_List]') AND type in (N'P', N'PC'))
)
OR
(
  NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_Insert]') AND type in (N'P', N'PC'))
)
OR
(
  NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_UpdateDescription]') AND type in (N'P', N'PC'))
)
OR
(
 NOT EXISTS (SELECT * FROM sysobjects WHERE id = OBJECT_ID(N'[dbo].[spPragmaSQL_ObjectGroup_GetHelpText]') AND type in (N'P', N'PC'))
) 
BEGIN
  SELECT 0 'Result'
END ELSE BEGIN
  SELECT 1 'Result'
END</value>
  </data>
  <data name="Script_CodeCompletionProposalWithoutProcParams" xml:space="preserve">
    <value>DECLARE @r table
(
  [Order] int null,
  Type varchar(10) null,
  Catalog sysname null,
  [Schema] sysname null,
  ParentName sysname null,
  Name sysname null,
  DisplayName sysname null,
  DataType sysname null,
  QualifiedDataType sysname null,
  IsOffline bit
)




-- Tables
insert into @r([Order], Type,Catalog,[Schema],ParentName, Name, DisplayName, DataType, QualifiedDataType )
select
  0
  ,'Tbl',TABLE_CATALOG, TABLE_SCHEMA,'', TABLE_NAME , TABLE_NAME, 'Table','Table'
from  INFORMATION_SCHEMA.TABLES 
where TABLE_TYPE = 'BASE TABLE'

-- Views
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DisplayName,DataType, QualifiedDataType )
select
  1
  , 'Vw', TABLE_CATALOG, TABLE_SCHEMA, '', TABLE_NAME, TABLE_NAME, 'View','View'
from  INFORMATION_SCHEMA.VIEWS 

-- Procedures
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DisplayName,DataType, QualifiedDataType )
select 
  CASE ROUTINE_TYPE 
    WHEN 'PROCEDURE' THEN 2
    WHEN 'FUNCTION' THEN 3
    ELSE 1000
  END,
  CASE ROUTINE_TYPE 
    WHEN 'PROCEDURE' THEN 'Pr'
    WHEN 'FUNCTION' THEN 'Fu'
    ELSE '?'
  END,  
  ROUTINE_CATALOG, ROUTINE_SCHEMA,'', ROUTINE_NAME, ROUTINE_NAME, 
  CASE ROUTINE_TYPE 
    WHEN 'PROCEDURE' THEN 'Proc'
    WHEN 'FUNCTION' THEN 'Func'
    ELSE '?'
  END,  
  CASE ROUTINE_TYPE 
    WHEN 'PROCEDURE' THEN 'Proc'
    WHEN 'FUNCTION' THEN 'Func'
    ELSE '?'
  END

from INFORMATION_SCHEMA.ROUTINES 

-- Triggers
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DisplayName,DataType, QualifiedDataType )
select
  4,
  'Tr',
  '',
  '',
  po.name,
  o.name,
  o.name,
  'Trigger',
  'Trigger'
from sysobjects o
join sysobjects po on o.parent_obj = po.id
where o.xtype = 'tr'

-- Table Columns
insert into @r([Order], Type, Catalog,[Schema],ParentName, Name, DataType, DisplayName,QualifiedDataType )
select 
  5
 , 'Col'
 , TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, DATA_TYPE
 , CASE 
    WHEN DATA_TYPE = 'varchar' THEN COLUMN_NAME + ' ' + DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar)+ ')'
    WHEN DATA_TYPE = 'nvarchar' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'char' THEN COLUMN_NAME + ' ' +   DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nchar' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'binary' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nbinary' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'numeric' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar)+ ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
    WHEN DATA_TYPE = 'decimal' THEN COLUMN_NAME + ' ' +  DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar) + ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
  ELSE  COLUMN_NAME + ' ' + DATA_TYPE END
 , CASE 
    WHEN DATA_TYPE = 'varchar' THEN DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar)+ ')'
    WHEN DATA_TYPE = 'nvarchar' THEN DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'char' THEN DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nchar' THEN DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'binary' THEN DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'nbinary' THEN DATA_TYPE + '(' + CAST(CHARACTER_MAXIMUM_LENGTH as varchar) + ')'
    WHEN DATA_TYPE = 'numeric' THEN DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar)+ ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
    WHEN DATA_TYPE = 'decimal' THEN DATA_TYPE + '(' + CAST(NUMERIC_PRECISION as varchar) + ',' + CAST(NUMERIC_SCALE as varchar)+ ')'
  ELSE   DATA_TYPE END

from INFORMATION_SCHEMA.COLUMNS 


-- databases
insert into @r([Order], Type,Name,DisplayName,DataType, QualifiedDataType  )
select
  7
  ,'Db'  
  , name 
  , name
  , 'Db'
  , 'Db'
from  master..sysdatabases 

-- Users
insert into @r( [Order],Type,Name,DisplayName,DataType, QualifiedDataType  )
select 
  8
  ,'Usr' 
  ,name
  ,name
  ,'User'
  ,'User' 
from sysusers

select * from @r
order by [Order],Name</value>
  </data>
  <data name="Script_GetTableColumns" xml:space="preserve">
    <value>select   
  sc.*, case when LOWER( st.name) = 'nvarchar' or  LOWER( st.name) = 'nchar' THEN sc.length / 2 ELSE sc.length END 'lengthx'  
, st.name as typename
, case when( sc.status &amp; 0x80 = 0x80 )
    then 1
    else 0
  end as isIdentity ,USER_NAME(so.uid) as 'owner' 
from syscolumns sc
join sysobjects so on sc.id = so.id
left outer join systypes st on sc.xtype = st.xusertype
where ISNULL(sc.name,'') &lt;&gt; '' 
and so.name = '{0}'
order by 
isIdentity DESC
,  sc.colorder
, sc.name</value>
  </data>
  <data name="Script_GetTableIdentityIncrementAndSeed" xml:space="preserve">
    <value>SELECT 
  IDENT_SEED('{0}') AS idSeed
, IDENT_INCR('{0}') AS idIncrement
FROM INFORMATION_SCHEMA.TABLES
WHERE 
  TABLE_NAME = '{0}'
AND ( IDENT_SEED('{0}') IS NOT NULL )
AND ( IDENT_INCR('{0}') IS NOT NULL )</value>
  </data>
  <data name="Script_GetSynonyms" xml:space="preserve">
    <value>select
  so.*
  , SCHEMA_NAME(so.uid) as 'owner' 
  , CASE WHEN so.uid IS NULL 
		THEN (so.name)
		ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)
	END  AS FullName
from sysobjects so
where 
  ( so.xtype = 'SN')
order by
  so.name</value>
  </data>
  <data name="Script_GetSynonymInformation" xml:space="preserve">
    <value>SELECT
s.name AS [Name],
s.object_id AS [ID],
s.create_date AS [CreateDate],
s.modify_date AS [DateLastModified],
SCHEMA_NAME(s.schema_id) AS [Schema],
s.base_object_name AS [BaseObjectName]
FROM
sys.synonyms AS s
WHERE
(s.name=N'{0}')</value>
  </data>
  <data name="Script_GetAllTriggers" xml:space="preserve">
    <value>declare @compLevel smallint
select @compLevel = {0}

select
  so.*,
  CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END 'owner',
  
  CASE WHEN @compLevel &lt; 90 
	THEN  (USER_NAME(so.uid)) + '.' + (so.name)  
	ELSE (SCHEMA_NAME(so.uid)) + '.' + (so.name)  
  END 'FullName'
from sysobjects so
where 
   so.xtype = 'TR'
order by
 CASE WHEN @compLevel &lt; 90 
	THEN  USER_NAME(so.uid) 
	ELSE SCHEMA_NAME(so.uid)
  END,
  so.name</value>
  </data>
  <data name="Script_ObjectGroupingSupport_GetAllParents" xml:space="preserve">
    <value>DECLARE @ParentID int
DECLARE @tmp varchar(8000)
DECLARE @comma varchar(1)

SELECT @ParentID = ParentID FROM PragmaSQLObjectGroup
WHERE ObjectID = {0}

IF @ParentID IS NULL BEGIN
  SELECT STR(@ParentID)
  RETURN
END

SELECT @tmp = LTRIM(STR(@ParentID))
SET @comma = ','

WHILE not ( @ParentID is null ) BEGIN
  SELECT @ParentID = ParentID FROM PragmaSQLObjectGroup
  WHERE ObjectID = @ParentID
  IF @ParentID is null
    break
    
  SELECT @tmp = @tmp + ISNULL(@comma,'') + LTRIM(STR(@ParentID))
END

SELECT @tmp</value>
  </data>
  <data name="Script_ObjectGroupingSupportGroupStats" xml:space="preserve">
    <value>DECLARE @Name varchar(8000)
DECLARE @ParentName varchar(4000)
DECLARE @ParentID int
DECLARE @ObjectID int
DECLARE @comma varchar(1)
DECLARE @tmp varchar(8000)
DECLARE @paths table(id int,name varchar(4000), path varchar(8000))
DECLARE @objIds table(ObjectID int)

SELECT @Name = '{0}'

INSERT INTO @objIds 
SELECT ObjectId FROM PragmaSQLObjectGroup
WHERE LOWER(Name) = LOWER(@Name)


DECLARE oCur CURSOR READ_ONLY FAST_FORWARD FOR
SELECT ObjectID FROM @objIds

  
OPEN oCur
WHILE (1=1) BEGIN
  FETCH NEXT FROM oCur INTO @ObjectID
  IF @@FETCH_STATUS &lt;&gt; 0  BREAK
  
  SELECT @comma = ''
  SELECT @ParentName = ''
  SELECT @tmp = ''
  
  SELECT
    @ParentID = ParentID
  FROM PragmaSQLObjectGroup
  WHERE ObjectID = @ObjectID

  IF @ParentID IS NULL 
    continue
  
 
  WHILE not ( @ParentID is null ) BEGIN
    SELECT 
      @ParentName = Name
      , @ParentID = ParentID 
    FROM PragmaSQLObjectGroup
    WHERE ObjectID = @ParentID
   

    SELECT @tmp =  RTRIM(LTRIM(@ParentName)) + ISNULL(@comma,'') + @tmp
    SET @comma = '\\'
  END
  
  INSERT INTO @paths
  SELECT @ObjectID,@Name, @tmp
END
CLOSE oCur
DEALLOCATE oCur

select * from @paths</value>
  </data>
  <data name="Script_ObjectList" xml:space="preserve">
    <value>declare @cmplevel int select @cmplevel = cmptlevel  from  master..sysdatabases where name = DB_NAME()

declare @types table(shortType varchar(3), longType varchar(50))
insert into @types
select 'U','Table'

insert into @types
select 'V','View'

insert into @types
select 'FN','UserDefinedFunction'

insert into @types
select 'TF','UserDefinedFunction'

insert into @types
select 'IF','UserDefinedFunction'


insert into @types
select 'P','StoredProcedure'

insert into @types
select 'X','StoredProcedure'



SELECT
	so.id,
	so.[name], 
	so.xtype, 
	T.longType,
	CASE WHEN @cmplevel &lt; 90 
		THEN  USER_NAME(so.uid) 
		ELSE SCHEMA_NAME(so.uid)
	END 'owner'
FROM sysobjects  so
join @types T on T.shortType = so.xtype 
WHERE T.longType = '{0}' and LOWER(so.[name]) like(LOWER('{1}'))
order by 
    CASE WHEN @cmplevel &lt; 90 
		THEN  USER_NAME(so.uid) 
		ELSE SCHEMA_NAME(so.uid)
	END
	,so.name</value>
  </data>
  <data name="Script_ObjectListAll" xml:space="preserve">
    <value>declare @cmplevel int select @cmplevel = cmptlevel  from  master..sysdatabases where name = DB_NAME()

declare @types table(shortType varchar(3), longType varchar(50))
insert into @types
select 'U','Table'

insert into @types
select 'V','View'

insert into @types
select 'FN','UserDefinedFunction'

insert into @types
select 'TF','UserDefinedFunction'

insert into @types
select 'IF','UserDefinedFunction'


insert into @types
select 'P','StoredProcedure'

insert into @types
select 'X','StoredProcedure'

SELECT
	so.id,
	so.[name], 
	so.xtype, 
	T.longType,
	CASE WHEN @cmplevel &lt; 90 
		THEN  USER_NAME(so.uid) 
		ELSE SCHEMA_NAME(so.uid)
	END 'owner'
FROM sysobjects  so
join @types T on T.shortType = so.xtype 
WHERE T.longType in({0}) and LOWER(so.[name]) like(LOWER('{1}'))
order by
	CASE WHEN @cmplevel &lt; 90 
		THEN  USER_NAME(so.uid) 
		ELSE SCHEMA_NAME(so.uid)
	END 
	, so.name</value>
  </data>
  <data name="Script_ObjectList_InCriteria" xml:space="preserve">
    <value>'U', 'V', 'FN', 'TF', 'IF', 'P', 'X'</value>
  </data>
  <data name="Script_GetDataTypes" xml:space="preserve">
    <value>declare @cmplevel int
select @cmplevel = cmptlevel 
from  master..sysdatabases 
where name = DB_NAME()

SELECT 
	CASE WHEN @cmplevel &lt; 90 
		THEN USER_NAME(types1.uid) 
		ELSE SCHEMA_NAME(types1.uid) 
	END 'owner',
	CASE WHEN USER_NAME(types1.uid) = 'sys' 
		THEN LOWER(types1.name)  
		ELSE LOWER( ((CASE WHEN @cmplevel &lt; 90  THEN USER_NAME(types1.uid) ELSE  SCHEMA_NAME(types1.uid) END )) + '.' + (types1.name)) 
	END AS 'name',
	CASE WHEN (CASE WHEN @cmplevel &lt; 90  THEN USER_NAME(types1.uid) ELSE  SCHEMA_NAME(types1.uid) END ) = 'sys' 
		THEN LOWER(types1.name)  
		ELSE LOWER(((CASE WHEN @cmplevel &lt; 90  THEN USER_NAME(types1.uid) ELSE  SCHEMA_NAME(types1.uid) END )) + '.' + (types1.name) ) 
		END AS  'basename',
	types1.length, types1.prec, types1.scale, 
	types1.allownulls, types1.usertype, OBJECT_NAME(types1.[domain]) 'domain', OBJECT_NAME(types1.tdefault) 'default'
FROM dbo.systypes types1
ORDER BY types1.name</value>
  </data>
  <data name="Script_GetIndexProperties" xml:space="preserve">
    <value>declare @cmplevel int
select @cmplevel = cmptlevel 
from  master..sysdatabases 
where name = DB_NAME()


  SELECT 
	I.name,
	(
	CASE WHEN @cmplevel &lt; 90 
		THEN USER_NAME(O.uid) 
		ELSE SCHEMA_NAME(O.uid) 
	END ) 'owner'
	, O.id
	, (O.name) as objectName 
	, ( CASE WHEN @cmplevel &lt; 90 THEN USER_NAME(O.uid) ELSE SCHEMA_NAME(O.uid) END ) + '.' + (O.name) as QuotedFullName
  FROM sysobjects O,sysindexes I 
   WHERE I.indid = {0} AND O.id = {1} AND 
  I.status&amp;2048!=2048 AND I.status&amp;4096!=4096 AND I.id=O.id AND type in ('U','V') 
  AND (INDEXPROPERTY(I.id,I.name,'IsStatistics') &lt;&gt; 1) AND (INDEXPROPERTY(I.id,I.name,'IsAutoStatistics') &lt;&gt; 1) 
  AND (INDEXPROPERTY(I.id,I.name,'IsHypothetical') &lt;&gt; 1) AND O.type!='S'</value>
  </data>
</root>